Perfecto ðŸ”¥ â€” esto que quieres **NO se puede conseguir con `CardDefaults.cardElevation()`**, porque:

- Las sombras de Material3 son **uniformes** (misma elevaciÃ³n en todo el borde)
    
- EstÃ¡n **ligadas al sistema de elevaciÃ³n de Material Design**
    
- No permiten sombras direccionales
    
- No permiten sombras mÃ¡s cargadas abajo que arriba
    
- Y se â€œrecortanâ€ siempre usando **un rectÃ¡ngulo interno** (clip)
    

ðŸ‘‰ Por eso tu sombra se ve â€œcuadradaâ€, aunque el Card sea redondeado.

La soluciÃ³n es usar **sombras personalizadas** usando `Modifier.shadow()`,  
que sÃ­ permite:

âœ” sombras con la forma del Card  
âœ” mÃ¡s fuerte abajo, suave arriba  
âœ” sin recorte rectangular  
âœ” colores y blur personalizados

---

# âœ¨ SOLUCIÃ“N: sombra personalizada suave abajo (parcial superior limpia)

## â­ OpciÃ³n profesional usando `Modifier.drawBehind`

Este mÃ©todo te da control TOTAL sobre la sombra:

```kotlin
@Composable
fun ShadowCard(
    expanded: Boolean,
    modifier: Modifier = Modifier,
    content: @Composable () -> Unit
) {
    val cornerRadius = with(LocalDensity.current) { 20.dp.toPx() }
    val shadowColor = Color.Black.copy(alpha = 0.25f)

    Box(
        modifier = modifier
            .fillMaxWidth()
            .padding(12.dp)
            .graphicsLayer {
                // Para permitir que la sombra se dibuje fuera del contenedor
                shadowElevation = 0f
                shape = RoundedCornerShape(20.dp)
                clip = false
            }
            .drawBehind {
                // SOMBRA CUSTOM (MAS FUERTE ABAJO)
                drawRoundRect(
                    color = shadowColor,
                    cornerRadius = CornerRadius(cornerRadius),
                    topLeft = Offset(0f, 8f),    // ðŸ”¥ desplazada hacia abajo
                    size = Size(size.width, size.height),
                    alpha = 0.6f,                // intensidad
                    blendMode = BlendMode.SrcOver
                )
            }
    ) {
        Card(
            onClick = {},
            shape = RoundedCornerShape(20.dp),
            colors = CardDefaults.cardColors(
                containerColor = MaterialTheme.colorScheme.primary
            ),
            elevation = CardDefaults.cardElevation(0.dp) // â— sin elevaciÃ³n base
        ) {
            content()
        }
    }
}
```

---

# ðŸ§  Â¿QuÃ© hace esto?

### âœ” La sombra se dibuja **manualmente** detrÃ¡s del card

Usamos `drawRoundRect()` con radio de esquina igual a la forma real del Card.

### âœ” La sombra queda **mÃ¡s fuerte abajo**

Porque la desplazamos:

```kotlin
topLeft = Offset(0f, 8f)
```

### âœ” No hay sombra arriba

Porque arriba no llega al borde.

### âœ” No se recorta a un rectÃ¡ngulo

Porque:

```kotlin
clip = false
```

### âœ” No usamos elevaciÃ³n de Material

Si la usas, te vuelve a poner la sombra rectangular.

---

# ðŸŽ¨ Puedes tunear fÃ¡cilmente:

### ðŸ‘‰ Intensidad (mÃ¡s oscura / clara)

```kotlin
alpha = 0.6f
```

### ðŸ‘‰ CuÃ¡nto se desplaza hacia abajo:

```kotlin
topLeft = Offset(0f, 12f)
```

### ðŸ‘‰ Blur suave usando `drawIntoCanvas`

Para una sombra **ultra suave**, tipo neumorfismo:

```kotlin
.drawBehind {
    this.drawIntoCanvas { canvas ->
        val paint = Paint().asFrameworkPaint()
        paint.color = shadowColor.toArgb()
        paint.setMaskFilter(BlurMaskFilter(30f, BlurMaskFilter.Blur.NORMAL))
        canvas.drawRoundRect(0f, 12f, size.width, size.height, cornerRadius, cornerRadius, paint)
    }
}
```

ðŸ”¥ Esto te da sombras estilo **iOS / Figma**, mucho mÃ¡s suaves.

---

# ðŸŸ£ Si quieres mantener tu cÃ³digo actual y solo reemplazar la sombra

Usa:

```kotlin
Card(
    ...,
    modifier = Modifier
        .shadow(
            elevation = if (expanded) 12.dp else 4.dp,
            shape = RoundedCornerShape(20.dp),
            clip = false
        )
        .background(MaterialTheme.colorScheme.primary, RoundedCornerShape(20.dp))
)
```

Pero **restrictivo**: Compose usa blur uniforme arriba/abajo.

---

# ðŸŽ¯ RECOMENDACIÃ“N FINAL

Para **sombra curva + mÃ¡s intensa abajo + nada arriba**,  
la **Ãºnica forma perfecta** es con `drawBehind` y una sombra manual.

Si quieres, puedo hacerte:

- una versiÃ³n paramÃ©trica (`shadowBottomOnly(elevation, radius)`)
    
- o un **modifier reutilizable**:  
    `Modifier.bottomShadow(elevation = 12.dp, radius = 20.dp)`
    
- o una **sombra multilayer** como se usa en Dribbble/Figma
    

Â¿Quieres que prepare el modifier reutilizable?