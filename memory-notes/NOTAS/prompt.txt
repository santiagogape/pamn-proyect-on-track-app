tengo:
class GoogleAuthClient(private val context: Context) {
    private val auth = FirebaseAuth.getInstance()
    private val db = FirebaseFirestore.getInstance()
    private val credentialManager = CredentialManager.create(context)

    suspend fun signIn(activityContext: Context): Boolean {
        try {
            // 1. Build the Google Sign-In Request
            val googleIdOption = GetGoogleIdOption.Builder()
                .setFilterByAuthorizedAccounts(false)
                .setServerClientId("__-___.apps.googleusercontent.com")
                .setAutoSelectEnabled(true)
                .build()

            val request = GetCredentialRequest.Builder()
                .addCredentialOption(googleIdOption)
                .build()

            // 2. Launch the Android system bottom sheet
            val result = credentialManager.getCredential(
                request = request,
                context = activityContext
            )

            // 3. Extract the ID Token from the result
            val credential = result.credential
            if (credential is CustomCredential &&
                credential.type == GoogleIdTokenCredential.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL) {

                val googleCred = GoogleIdTokenCredential.createFrom(credential.data)
                val idToken = googleCred.idToken

                // 4. Exchange Google Token for Firebase Credential
                val firebaseCredential = GoogleAuthProvider.getCredential(idToken, null)
                auth.signInWithCredential(firebaseCredential).await()

                return true
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
        return false
    }

    fun getUserId(): String? = auth.currentUser?.uid

    suspend fun ensureUserExists() {
        val user = auth.currentUser ?: return
        val userDocRef = db.collection("users").document(user.uid)

        val snapshot = userDocRef.get().await()

        if (!snapshot.exists()) {
            // First time login! Create the user document.
            val newUser = User(
                id = user.uid,
                email = user.email ?: "",
                username = user.displayName ?: ""
            )
            userDocRef.set(newUser).await()
        }
    }
}



class LoginViewModel(
    private val configureLocal: LocalConfigRepository,
    private val authClient: AuthClient,
    private val syncEngine: SyncEngine
) : ViewModel() {
    private val _signInState = MutableStateFlow<SignInState>(SignInState.Initial)
    val signInState = _signInState.asStateFlow()

    fun signIn(context: android.content.Context) {
        _signInState.value = SignInState.Loading

        viewModelScope.launch {
            val isSuccess = authClient.signIn(context)
            if (isSuccess) {
                // IMPORTANT: Create the user doc in Firestore if it doesn't exist
                authClient.ensureUserExists()
                runBlocking(Dispatchers.IO) {
                    authClient.getUser()?.let {configureLocal.init(it)}
                }
                syncEngine.start()
                runBlocking(Dispatchers.IO){
                    configureLocal.get().let {
                        Log.d("SyncDebug","\nuser:${it.userID}\n\n")
                        syncEngine.onLocalChange(it.userID,UserDTO::class)
                    }
                }
                _signInState.value = SignInState.Success
            } else {
                _signInState.value = SignInState.Error("Sign in failed")
            }
        }
    }
}

sealed class SignInState {
    object Initial : SignInState()
    object Loading : SignInState()
    object Success : SignInState()
    data class Error(val message: String) : SignInState()
}


@Composable
fun LoginScreen(
    viewModel: LoginViewModel,
    onLoginSuccess: () -> Unit, // Callback to navigate when login finishes
) {
    // We get the ViewModel using your custom factory

    val state by viewModel.signInState.collectAsState()
    val context = LocalContext.current

    // React to state changes
    LaunchedEffect(state) {
        if (state is SignInState.Success) {
            onLoginSuccess()
        } else if (state is SignInState.Error) {
            Toast.makeText(context, (state as SignInState.Error).message, Toast.LENGTH_LONG).show()
        }
    }

    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Text(
                text = "Welcome to OnTrack",
                style = MaterialTheme.typography.headlineMedium
            )

            Spacer(modifier = Modifier.height(32.dp))

            if (state is SignInState.Loading) {
                CircularProgressIndicator()
            } else {
                Button(
                    onClick = { viewModel.signIn(context) },
                    modifier = Modifier.fillMaxWidth(0.7f)
                ) {
                    Text(text = "Sign in with Google")
                }
            }
        }
    }
}

class OnTrackApp : Application() {


    lateinit var viewModelsFactory: ViewModelsFactoryMock
    lateinit var applicationScope: CoroutineScope

    lateinit var localConfig: UniqueRepository<LocalConfigurations>

    lateinit var currentOwnership: OwnershipContext
    lateinit var authViewModelFactory: ()-> LoginViewModel
    lateinit var authenticationCheck: () -> MockUser?


    override fun onCreate() {
        super.onCreate()


        // coroutine scope for global services and coroutines
        applicationScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)




        //init
        val localConfigRepo = LocalConfigRepository(RealmDatabase.realm)

        localConfig = localConfigRepo
        currentOwnership = OwnershipContext("",null,null)


        val integrityManager = ReferenceIntegrityManager(mutableMapOf())




        //local repositories
        val repoUser = RealmUserRepository(
            RealmDatabase.realm, USER_MAPPER, { UserRealmEntity() },
            UserRealmEntity::class, UserDTO::class,integrityManager
        )
        val repoGroup = RealmGroupRepository(
            RealmDatabase.realm, GROUP_MAPPER, { GroupRealmEntity() },
            GroupRealmEntity::class, GroupDTO::class, integrityManager
        )
        val repoProject = RealmProjectRepository(RealmDatabase.realm,PROJECT_MAPPER,{ ProjectRealmEntity() },
            ProjectRealmEntity::class, ProjectDTO::class,integrityManager )
        val repoMembership = RealmMembershipRepository(RealmDatabase.realm,MEMBERSHIP_MAPPER, { RealmMembershipEntity() },
            RealmMembershipEntity::class, MembershipDTO::class,integrityManager)
        val repoEvent = RealmEventRepository(
            RealmDatabase.realm, EVENT_MAPPER, { EventRealmEntity() },
            EventRealmEntity::class, EventDTO::class, integrityManager
        )
        val repoTask = RealmTaskRepository(
            RealmDatabase.realm, TASK_MAPPER, { TaskRealmEntity() },
            TaskRealmEntity::class, TaskDTO::class, integrityManager
        )
        val repoReminder = RealmReminderRepository(
            RealmDatabase.realm, REMINDER_MAPPER, { ReminderRealmEntity() },
            ReminderRealmEntity::class, ReminderDTO::class, integrityManager
        )

        integrityManager.addClassAndEntry(UserDTO::class, ReferenceIntegrityManagerEntry(
                dtoClass = UserDTO::class,
                propagate = { localId, cloudId ->
                    repoGroup.synchronizeReferences(localId,cloudId)
                    repoProject.synchronizeReferences(localId,cloudId)
                    repoMembership.synchronizeReferences(localId,cloudId)
                    repoTask.synchronizeReferences(localId,cloudId)
                    repoEvent.synchronizeReferences(localId,cloudId)
                    repoReminder.synchronizeReferences(localId,cloudId)
                },
                mapOf()
            )
        )

        integrityManager.addClassAndEntry(GroupDTO::class, ReferenceIntegrityManagerEntry(
            dtoClass = GroupDTO::class,
            propagate = { localId, cloudId ->
                repoProject.synchronizeReferences(localId,cloudId)
                repoMembership.synchronizeReferences(localId,cloudId)
                repoTask.synchronizeReferences(localId,cloudId)
                repoEvent.synchronizeReferences(localId,cloudId)
                repoReminder.synchronizeReferences(localId,cloudId)
            },mapOf(
                Filter.OWNER to {id->repoUser.getRemoteOf(id)}
            )
        ))

        integrityManager.addClassAndEntry(ProjectDTO::class, ReferenceIntegrityManagerEntry(
            dtoClass = ProjectDTO::class,
            propagate = {localId, cloudId ->
                repoMembership.synchronizeReferences(localId,cloudId)
                repoTask.synchronizeReferences(localId,cloudId)
                repoEvent.synchronizeReferences(localId,cloudId)
            },
            resolve = mapOf(
                Filter.OWNER to {id->repoUser.getRemoteOf(id) ?: repoGroup.getRemoteOf(id)}
            )
        ))

        integrityManager.addClassAndEntry(MembershipDTO::class, ReferenceIntegrityManagerEntry(
                dtoClass = MembershipDTO::class,
                propagate = { _,_ -> },
                resolve = mapOf(
                    Filter.MEMBERSHIP_ENTITY to {id->repoGroup.getRemoteOf(id) ?: repoProject.getRemoteOf(id)},
                    Filter.MEMBERSHIP_MEMBER to {id->repoUser.getRemoteOf(id)}
                )
            )
        )

        integrityManager.addClassAndEntry(TaskDTO::class, ReferenceIntegrityManagerEntry(
                dtoClass = TaskDTO::class,
                propagate = { localId, cloudId ->
                    repoReminder.synchronizeReferences(localId,cloudId)},
                resolve = mapOf(
                    Filter.PROJECT to {id->repoProject.getRemoteOf(id)},
                    Filter.OWNER to {id->repoUser.getRemoteOf(id) ?: repoGroup.getRemoteOf(id)}
                )
            )
        )

        integrityManager.addClassAndEntry(EventDTO::class, ReferenceIntegrityManagerEntry(
                dtoClass = EventDTO::class,
                propagate = { localId, cloudId ->
                    repoReminder.synchronizeReferences(localId,cloudId)},
                resolve = mapOf(
                    Filter.PROJECT to {id->repoProject.getRemoteOf(id)},
                    Filter.OWNER to {id->repoUser.getRemoteOf(id) ?: repoGroup.getRemoteOf(id)}
                )
            )
        )

        integrityManager.addClassAndEntry(ReminderDTO::class, ReferenceIntegrityManagerEntry(
            dtoClass = ReminderDTO::class,
            propagate = {_,_ ->},
            resolve = mapOf(
                Filter.OWNER to {id->repoUser.getRemoteOf(id) ?: repoGroup.getRemoteOf(id)} ,
                Filter.LINK to {id->repoTask.getRemoteOf(id) ?: repoEvent.getRemoteOf(id)}

            )
        ))

        //remote repositories

        val remoteUserRepo = FirestoreSyncRepository(
            clazz = UserDTO::class.java,
            db = FirestoreService.firestore,
            collectionName = "Users"
        )
        val remoteGroupRepo = FirestoreSyncRepository(
            clazz = GroupDTO::class.java,
            db = FirestoreService.firestore,
            collectionName = "Groups"
        )
        val remoteProjectRepo = FirestoreSyncRepository(
            clazz = ProjectDTO::class.java,
            db = FirestoreService.firestore,
            collectionName = "Projects"
        )

        val remoteMembershipRepo = FirestoreSyncRepository(
            clazz = MembershipDTO::class.java,
            db = FirestoreService.firestore,
            collectionName = "Memberships"
        )


        val remoteEventRepo = FirestoreSyncRepository(
            clazz = EventDTO::class.java,
            db = FirestoreService.firestore,
            collectionName = "Events"
        )
        val remoteTaskRepo = FirestoreSyncRepository(
            clazz = TaskDTO::class.java,
            db = FirestoreService.firestore,
            collectionName = "Tasks"
        )
        val remoteReminderRepo = FirestoreSyncRepository(
            clazz = ReminderDTO::class.java,
            db = FirestoreService.firestore,
            collectionName = "Reminders"
        )

        //view model factory using repositories
        viewModelsFactory = ViewModelsFactoryMock(
            mapOf(
                CreationViewModel::class to ViewModelsFactoryMock.FactoryEntry(
                    vmClass = CreationViewModel::class.java,
                    creator = { CreationViewModel(repoProject, repoEvent, repoTask,repoReminder) }
                ),
                UsersViewModel::class to ViewModelsFactoryMock.FactoryEntry(
                    vmClass = UsersViewModel::class.java,
                    creator = { UsersViewModel(repoUser) }
                ),
                GroupsViewModel::class to ViewModelsFactoryMock.FactoryEntry(
                    vmClass = GroupsViewModel::class.java,
                    creator = { GroupsViewModel(repoGroup) }
                ),
                ProjectsViewModel::class to ViewModelsFactoryMock.FactoryEntry(
                    vmClass = ProjectsViewModel::class.java,
                    creator = { ProjectsViewModel(repoProject) }
                ),
                MembershipsViewModel::class to ViewModelsFactoryMock.FactoryEntry(
                    vmClass = MembershipsViewModel::class.java,
                    creator = { MembershipsViewModel(repoMembership) }
                ),
                TasksViewModel::class to ViewModelsFactoryMock.FactoryEntry(
                    vmClass = TasksViewModel::class.java,
                    creator = { TasksViewModel(repoTask) }
                ),
                EventsViewModel::class to ViewModelsFactoryMock.FactoryEntry(
                    vmClass = EventsViewModel::class.java,
                    creator = { EventsViewModel(repoEvent) }
                ),
                RemindersViewModel::class to ViewModelsFactoryMock.FactoryEntry(
                    vmClass = RemindersViewModel::class.java,
                    creator = { RemindersViewModel(repoReminder) }
                ),
                CalendarViewModel::class to ViewModelsFactoryMock.FactoryEntry(
                    vmClass = CalendarViewModel::class.java,
                    creator = { CalendarViewModel(repoEvent) }
                ), HomeViewModel::class to ViewModelsFactoryMock.FactoryEntry(
                    vmClass = HomeViewModel::class.java,
                    creator = { HomeViewModel() }
                )
            )
        )


        val syncRepositoryFactory by lazy {
            SyncRepositoryFactory(
                listOf(
                    SyncRepositoryEntry(
                        dtoClass = UserDTO::class,
                        local = repoUser,
                        remote = remoteUserRepo),
                    SyncRepositoryEntry(
                        dtoClass = GroupDTO::class,
                        local = repoGroup,
                        remote = remoteGroupRepo
                    ),
                    SyncRepositoryEntry(
                        dtoClass = ProjectDTO::class,
                        local = repoProject,
                        remote = remoteProjectRepo
                    ),
                    SyncRepositoryEntry(
                        dtoClass = MembershipDTO::class,
                        local = repoMembership,
                        remote = remoteMembershipRepo
                    ),
                    SyncRepositoryEntry(
                        dtoClass = TaskDTO::class,
                        local = repoTask,
                        remote = remoteTaskRepo
                    ),
                    SyncRepositoryEntry(
                        dtoClass = EventDTO::class,
                        local = repoEvent,
                        remote = remoteEventRepo
                    ),
                    SyncRepositoryEntry(
                        dtoClass = ReminderDTO::class,
                        local = repoReminder,
                        remote = remoteReminderRepo
                    )
                )
            )
        }

        // Sync Engine
        val syncEngine by lazy {
            SyncEngine(
                factory = syncRepositoryFactory,
                scope = applicationScope
            )
        }
        val auth = GoogleAuthClient(this)
        val configRepo = LocalConfigRepository(RealmDatabase.realm)
        authViewModelFactory = {LoginViewModel(
            configRepo,
            auth,
            syncEngine
        )}

        authenticationCheck = {if(configRepo.ready()) repoUser.getById(configRepo.get().userID) else auth.getUser()}

    }
}


val PROJECT_MAPPER = object: SyncMapper<ProjectRealmEntity, ProjectDTO, MockProject> {
    override fun toLocal(dto: ProjectDTO, entity: ProjectRealmEntity) { dto.toRealm(entity) }
    override fun toDTO(entity: ProjectRealmEntity): ProjectDTO { return entity.toDTO() }
    override fun toDomain(entity: ProjectRealmEntity): MockProject { return entity.toDomain() }
}

val EVENT_MAPPER = object: SyncMapper<EventRealmEntity, EventDTO, MockEvent> {
    override fun toLocal(dto: EventDTO, entity: EventRealmEntity) { dto.toRealm(entity) }
    override fun toDTO(entity: EventRealmEntity): EventDTO { return entity.toDTO() }
    override fun toDomain(entity: EventRealmEntity): MockEvent { return entity.toDomain() }
}

val GROUP_MAPPER = object: SyncMapper<GroupRealmEntity, GroupDTO, MockGroup> {
    override fun toLocal(dto: GroupDTO, entity: GroupRealmEntity) { dto.toRealm(entity) }
    override fun toDTO(entity: GroupRealmEntity): GroupDTO { return entity.toDTO() }
    override fun toDomain(entity: GroupRealmEntity): MockGroup { return entity.toDomain() }
}

val USER_MAPPER = object: SyncMapper<UserRealmEntity, UserDTO, MockUser> {
    override fun toLocal(dto: UserDTO, entity: UserRealmEntity) { dto.toRealm(entity) }
    override fun toDTO(entity: UserRealmEntity): UserDTO { return entity.toDTO() }
    override fun toDomain(entity: UserRealmEntity): MockUser { return entity.toDomain() }
}

val REMINDER_MAPPER = object: SyncMapper<ReminderRealmEntity, ReminderDTO, MockReminder> {
    override fun toLocal(dto: ReminderDTO, entity: ReminderRealmEntity) { dto.toRealm(entity) }
    override fun toDTO(entity: ReminderRealmEntity): ReminderDTO { return entity.toDTO() }
    override fun toDomain(entity: ReminderRealmEntity): MockReminder { return entity.toDomain() }
}
val TASK_MAPPER = object: SyncMapper<TaskRealmEntity, TaskDTO, MockTask> {
    override fun toLocal(dto: TaskDTO, entity: TaskRealmEntity) { dto.toRealm(entity) }
    override fun toDTO(entity: TaskRealmEntity): TaskDTO { return entity.toDTO() }
    override fun toDomain(entity: TaskRealmEntity): MockTask { return entity.toDomain() }
}

val MEMBERSHIP_MAPPER = object: SyncMapper<RealmMembershipEntity, MembershipDTO, Membership> {
    override fun toLocal(dto: MembershipDTO, entity: RealmMembershipEntity) { dto.toRealm(entity) }
    override fun toDTO(entity: RealmMembershipEntity): MembershipDTO { return entity.toDTO() }
    override fun toDomain(entity: RealmMembershipEntity): Membership { return entity.toDomain() }
}


class MainActivity : ComponentActivity() {
    private val settings by lazy { SettingsDataStore(this) }
    private val factory by lazy {
        (application as OnTrackApp).viewModelsFactory
    }

    private val config by lazy {
        (application as OnTrackApp).localConfig
    }

    private val ownershipContext by lazy {
        (application as OnTrackApp).currentOwnership
    }

    private val checkAuth by lazy {
        (application as OnTrackApp).authenticationCheck
    }

    private val loginViewModelFactory by lazy {
        (application as OnTrackApp).authViewModelFactory
    }



    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContent {

            val darkTheme by settings.darkThemeFlow.collectAsState(initial = false)
            var auth by remember { mutableStateOf(checkAuth()) }
            if (auth == null) {
                LoginScreen(
                    viewModel = loginViewModelFactory(),
                    onLoginSuccess = {auth = checkAuth()}
                )
            } else {
                CompositionLocalProvider(
                    LocalViewModelFactory provides factory,
                    LocalConfig provides LocalConfigurations(config.get().userID),
                    LocalOwnership provides ownershipContext
                ) {
                    config.get().let { DebugLogcatLogger.logConfig(checkAuth()!!, "main") }
                    Main(
                        darkTheme = darkTheme,
                        onToggleTheme = {
                            lifecycleScope.launch {
                                settings.setDarkTheme(!darkTheme)
                            }
                        })
                }
            }
        }
    }
}

pero me esta saltando el toast con "Sign in failed"

androidx.credentials.exceptions.NoCredentialException: During begin sign in, failure response from one tap: 10: [28444] Developer console is not set up correctly.
2025-12-15 07:48:28.414 13488-13488 System.err              com.example.on_track_app             W  	at androidx.credentials.playservices.controllers.CredentialProviderBaseController$Companion.getCredentialExceptionTypeToException$credentials_play_services_auth_release(CredentialProviderBaseController.kt:114)
2025-12-15 07:48:28.414 13488-13488 System.err              com.example.on_track_app             W  	at androidx.credentials.playservices.controllers.BeginSignIn.CredentialProviderBeginSignInController$resultReceiver$1$onReceiveResult$1.invoke(CredentialProviderBeginSignInController.kt:84)
2025-12-15 07:48:28.415 13488-13488 System.err              com.example.on_track_app             W  	at androidx.credentials.playservices.controllers.BeginSignIn.CredentialProviderBeginSignInController$resultReceiver$1$onReceiveResult$1.invoke(CredentialProviderBeginSignInController.kt:84)
2025-12-15 07:48:28.415 13488-13488 System.err              com.example.on_track_app             W  	at androidx.credentials.playservices.controllers.CredentialProviderController.maybeReportErrorFromResultReceiver(CredentialProviderController.kt:151)
2025-12-15 07:48:28.415 13488-13488 System.err              com.example.on_track_app             W  	at androidx.credentials.playservices.controllers.BeginSignIn.CredentialProviderBeginSignInController.access$maybeReportErrorFromResultReceiver(CredentialProviderBeginSignInController.kt:55)
2025-12-15 07:48:28.415 13488-13488 System.err              com.example.on_track_app             W  	at androidx.credentials.playservices.controllers.BeginSignIn.CredentialProviderBeginSignInController$resultReceiver$1.onReceiveResult(CredentialProviderBeginSignInController.kt:82)
2025-12-15 07:48:28.415 13488-13488 System.err              com.example.on_track_app             W  	at android.os.ResultReceiver$MyRunnable.run(ResultReceiver.java:50)
2025-12-15 07:48:28.415 13488-13488 System.err              com.example.on_track_app             W  	at android.os.Handler.handleCallback(Handler.java:942)
2025-12-15 07:48:28.415 13488-13488 System.err              com.example.on_track_app             W  	at android.os.Handler.dispatchMessage(Handler.java:99)
2025-12-15 07:48:28.415 13488-13488 System.err              com.example.on_track_app             W  	at android.os.Looper.loopOnce(Looper.java:240)
2025-12-15 07:48:28.415 13488-13488 System.err              com.example.on_track_app             W  	at android.os.Looper.loop(Looper.java:351)
2025-12-15 07:48:28.415 13488-13488 System.err              com.example.on_track_app             W  	at android.app.ActivityThread.main(ActivityThread.java:8377)
2025-12-15 07:48:28.415 13488-13488 System.err              com.example.on_track_app             W  	at java.lang.reflect.Method.invoke(Native Method)
2025-12-15 07:48:28.415 13488-13488 System.err              com.example.on_track_app             W  	at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:584)
2025-12-15 07:48:28.415 13488-13488 System.err              com.example.on_track_app             W  	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1013)


hay un error en lo que tengo actualmente para la autenticacion? o debo revisar el google-services.json?